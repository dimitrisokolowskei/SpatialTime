---
title: "SpatialTime Package"
author: Dimitri Sokolowskei, Alex Trostle, Robert Tower
output:
  html_document:
    fig_caption: yes
    theme: bootstrap
    toc: yes
    toc_depth: 3
    toc_float: yes
---

# SpatialTime 
Spatial transcriptomics (ST) enables single cell resolution gene expression analysis assessment across histology sections while preserving the tissue native morphological configuration. In this context, SpatialTime package empower users to access gene expression, pathways scores and co-expression gene modules by establishing spatially defined reference points and calculating ST spots distances against the arbitrarily defined reference spots using euclidean distances. Thus, a distance gradient can be established allowing the evaluation of gene expression profiling based on proximity of any reference line.     

## Installation
Package install via CRAN:
```sh
install.packages("SpatialTime")
```
Development version install:
```sh
#(install.packages("devtools")
devtools::install_github("dimitrisokolowskei/SpatialTime")
```
## Prerequisites
SpatialTime requires a spatial dataset already processed and integrated. Thus, any doubts on how to proceed with ST basic analysis, please visit [Seurat](https://satijalab.org/seurat/articles/spatial_vignette) vignette.

## Dataset 
For this vignette, we provide a ST example dataset obtained from [Rios et al., 2024](https://insight.jci.org/articles/view/176802#BIBL). The seurat object can be downloaded [here](put_link).

## Analysis Approaches
SpatialTime supports different strategies for delimiting spatial reference lines by: 1) Manually defining references spots using a build-in Shiny App; 2) Selecting single cell types based on clusters identities; 3) Manually defining references lines using imaging *softwares* such as Fiji/ImageJ;   

## 1. Individual Spots Selection
1.1 First, import processed Seurat object together with libraries required.
```sh
# Libraries
library(Seurat)
library(tidyverse)
library(Hmisc)
library(jsonlite)
library(monocle)
library(fs)
library(SpatialTime)

# set.seed for reproducibilty 
set.seed(12345)

# Import object
fracture <- readRDS("R/TrkA_annotation.rds")
```
1.2 Export cluster's XY coordinates of interess. Make sure that cell types labels are in Seurat object ```Idents()```. In case they're not, clusters labels from ```seurat@meta.data``` can be added into ```Idents()```. For instance:
```sh
Idents(fracture) # Check cluster names in Seurat object identity
Idents(fracture) <- fracture$cluster_labels # Add cluster label from metadata into identity

# Export cell type coordinates to desured directory
subset2Labels(fracture, cluster = c("Blastema", "Nailbed"), dir.out = "R/All_peri/")
```
1.3 Once clusters coordinates to be compared against to have been exported, we'll have to select our reference spots to establish the reference point for gradient distance. Using a build-in Shiny app allows the manual selection of how many spots in a sample slice as reference. To navigate trought the app, use ```shift+mouse``` to move around the sample and ```ctrl+left click``` to select the spots. In the top right corner there's ```+``` and ```-``` signs, allowing use to zoom in or out. When spots selection are done, click ```Export Selected Spots``` and close the Shiny app. 
```sh
# Selecting reference spots 
app <- ShinySelection(fracture)
```
By importing an cluster coordinates and reference spots previouly selected, SpatialTime distance gradient can be calculated. For example, using the cluster labeled as ```blastema```, it follows:
```sh
# Import coordinates of cluster and reference spots 
peri <- CoordMerge("R/All_peri/", pattern = "Blastema")
ref <- ShinySpots(fracture, coord_file = "selected_spots.csv")
# Calculate SpatialTime between cluster and reference ----
sp <- SpatialShinyTime(peri, ref)
```
The visualization of gradient distance is a import step since ensures that the desired distance axis between the clusters of interest is correct for the following steps. Additionaly, by subsetting out cells, using ```subset``` function. that were not included in the gradient distance calculation is recommended, since it allows a cleaner gradient visualization and faster processing for later steps  
```sh
# Visualize spots gradient 
vis <- SpatialVis(fracture, sp, spatial.by = "rel", slice = "slice1", return_obj = F)
vis

# Subset out spots which spatialtime (st) value were not calculated
vis <- subset(vis, subset = st != 0)
```

```sh
# Calculate pseudotime and visualize genes differentialy expressed across distance gradient
ps <- Pseudo2Time(vis, assay = "SCT", cores = 8, return_obj = F)
p <- plot_pseudotime_heatmap(ps, num_clusters = 2, cores = 2, show_rownames = F, return_heatmap = T)
p
```
```sh
# Visualize genes across pseudotime only 
ps <- Pseudo2Time(vis, assay = "SCT", cores = 8, return_obj = T)
GeneVis(file = ps, column = c("PDGFRA", "HBA1", "SOX9"), signal = "gene")
```
```sh
# Gene list pathways 
osteo <- c("Alpl","Bglap","Bglap2","Col1a1","Col1a2","Dmp1","Ibsp","Mef2c","Postn",
           "Runx2","Sp7","Sparc","Phex","Satb2","Pth1r","Ostn","Car3")

angio <- c("Cdh5","Ddit3","S1pr1","Ankrd17","Lyl1","Mmp2","Reck","Acvrl1")

# Add gene modules in object with pseudotime calculated
gene_modules <- list(Module1 = osteo, Module2 = angio)
module <- AddModuleScore(vis, features = gene_modules, assay = "SCT", name = "cluster") 
GeneVis(file = ps, column = c("cluster1", "cluster2"), signal = "pathway")
```






## 2. Cluster selection based approach
SpatialTime can also be obtained between two distinct cell type clusters previously annotated and present in your object ```Idents()```. The basic underlying idea is that the outermost spots of your reference cluster will be used to calculate the distance between the cluster of interest. The steps are pretty straightforward and much alike Fiji based strategy, with the benefit of not using third party tools to obtained comprehensive and significant biological information, although the freedom to delimit whatever area in the histology section become cell type restricted.   

2.1 
```sh
fracture <- readRDS("R/fracture_original_annotation.rds")
Idents(fracture)

subset2Labels(fracture, cluster = c("Bone Marrow", "Periosteum"), export.all = T, dir.out = "R/All_peri/")
```

2.2
```sh
# Selecting directories specific coordinates ----
peri <- CoordMerge("R/All_peri/", pattern = "Periosteum")
cort <- CoordMerge("R/All_peri/", pattern = "Bone Marrow")
```

2.3
```sh
# Calculate SpatialTime between clusters of interest ----
sp <- Spatial2Time(cort, peri)
```

2.4
```sh
# Visualize spots gradient ----
vis <- SpatialVis(fracture, sp, spatial.by = "rel", slice = "slice1.1", return_obj = F)
vis
```

2.5
```sh
# Pseudotime Calculation ----
ps <- PseudoTime(vis, assay = "SCT")
```

2.6
```sh
# Visualze Genes of interest
des <- GeneVis(ps, genes = c("HBA1","COL1A1","SOX9"))
View(des@meta.data)

ggplot(des@meta.data) +
  geom_smooth(aes(st, COL1A1, color = "COL1A1"), method = "loess", span = 1, se = FALSE) +
  geom_smooth(aes(st, SOX9, color = "SOX9"), method = "loess", span = 1, se = FALSE) +
  scale_color_manual(values = c("COL1A1" = "#E69F00", "SOX9" = "#56B4E9")) +
  theme_classic()
```

## 3. Fiji/ImageJ based approach
1.1 Fiji is a broadly used open source scientific image processing tool. Fiji allows drawing the reference lines of interest and exporting each delineated pixel as an XY coordinates later used for euclidean distance calculation. Fiji can be downloaded [here](https://imagej.net/software/fiji/) and a brief Fiji tutorial on how draw and export references lines can be found [here](to put).

1.2 First, import your Seurat ST object using ```readRDS()``` function. Then, we proceed using ```subsetLabels()``` which allows us to export ST clusters coordinates as excel sheets.
```sh
options(future.globals.maxSize=500000*1024^2)

# Required packages
library(Seurat)
library(tidyverse)
library(Hmisc)
library(jsonlite)
library(monocle)
library(fs)
library(SpatialTime)

# Import ST object
fracture <- readRDS("R/fracture_original_annotation.rds")

# Export clusters coordinates 
subsetLabels("R/fracture_original_annotation.rds", cluster = c("MarrowFibrin", "Periosteum", "Cortical"), slice.n = "slice1", export.all = T, dir.out = "R/Excel/")
```

1.3 Import Fiji XY coordinates previously prepared. Furthermore, we need to match the reference line colors to their respective tissue/region names. Be aware that the tissue names must exist in your Seurat object identities. Then, by running ```SpatialCalc()``` each XY coordinate can be transformed accordingly to the slice factor.  
```sh
fiji <- read.csv("R/fiji_output.csv")
colors <- c("Red", "Green", "Blue") 
tissue <- c("MarrowFibrin", "Periosteum", "Cortical") 

data <- SpatialCalc("R/fiji_output.csv", factor = "R/scalefactors_json.json", colors = colors, tissue = tissue) 
```

1.4 At this step, SpatialTime distance are ready to be calculated. First, import your cluster type coordinates as reference and calculate the spots distances against other cluster. 
```sh
# Calculate minimum spots distances from reference line of interest
file <- read.csv("R/Excel/Periosteum_coordinates.csv")

sp <- SpatialTime(file, "MarrowFibrin")
sp
```

1.5 
SpatialTime distance gradient can be assessed using:
```sh
# Visualization spatialtime gradient ----
vis <- SpatialVis(fracture, sp, spatial.by = "rel", remove.na = T, return_obj = T)
vis
View(vis@meta.data)
```

1.6 
```Pseudotime``` allows calculating and adding pseudotime values in the object metadata. By replacing the calculated spatialtime values into their respective pseudotime, it becomes possible to infer which genes are differential expressed as a gradient of distance. Briefly, we can assess which genes are up or downregulated as you move away from the reference line.  
```sh
# Calculate pseudotime ----
ps <- PseudoTime(vis, assay = "SCT", min_expr = 0.1, min_cells = 5, mean_expr = 0.1, cores = 8                                                       )
View(ps@meta.data)

p <- plot_pseudotime_heatmap(ps, num_clusters = 3, cores = 12, show_rownames = T, return_heatmap = T)
```

1.7 Basic Visualization 
```sh
des <- GeneVis(ps, genes = c("HBA1","COL1A1","SOX9"))
View(des@meta.data)


ggplot(des@meta.data) +
  geom_smooth(aes(st, COL1A1, color = "COL1A1"), method = "loess", span = 1, se = FALSE) +
  geom_smooth(aes(st, SOX9, color = "SOX9"), method = "loess", span = 1, se = FALSE) +
  scale_color_manual(values = c("COL1A1" = "#E69F00", "SOX9" = "#56B4E9")) +
  theme_classic()
```

